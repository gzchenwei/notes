* 算法
** 插入算法
*** 原理
**** 把数组分为a[0]-a[j-1],a[j]-a[len(a)-1)]
**** 前面部分是已经排好序的，后面的部分需要依次插入到前面的部分
**** 插入的时候，首先比较需要插入的值(key)同前一个值进行比较，如果<，则把当前的值更换为前一个值，然后将比较的值更新为前面的第二个值，直到找到当前的值> 前面的值，则结束循环
**** 将当天的位置的值更新为key
#+BEGIN_SRC 
for j in range(1,len(a)-1):
    key = a[i]
    i = j -1 
    if i >=0 and a[i] > key:
        a[i+1] = a[i]
        i = i - 1
    a[i + 1] = key
#+END_SRC
*** 算法复杂度
    插入算法同数组长度的平方成正比
** 归并算法
*** 原理
**** 将数组拆分为2个数组，然后再递归将数据拆分为长度为2或1的数组
**** 对最终的数组进行排序
**** 递归的归并已经排序好的数组，最终合并为最终的数组
#+BEGIN_SRC 
def merge(l,p,q,r):
    i = 0 
    j = 0
    a = l[p:q+1]
    b = l[q+1:r+1]
    a.append(float("inf"))
    b.append(float("inf"))
    for k in range(p,r+1):
        if a[i] > b[j]:
            l[k] = b[j]
            j = j + 1
        else:
            l[k] = a[i]
            i = i + 1

def mergesort(l,p,r):
    if p < r:
        q = (p + r)/2
        mergesort(l,p,q)
        mergesort(l,q+1,r)
        merge(l,p,q,r)

mergesort(x,0,len(l)-1)
#+END_SRC

